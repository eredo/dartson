import 'dart:convert';

import 'annotations.dart';
import 'exceptions.dart';

/// Provides the serializer to [encode] and [decode] entities. The serializer
/// encodes and decodes to respectively from Map<String, dynamic> by default.
/// In order to target different target provide a [_codec] within the
/// [Serializer] declaration.
class Dartson<R> {
  final Map<Type, DartsonEntity> _entities;

  /// If provided calls [encode] respectively [decode] on the codec.
  Codec<Object, R> _codec;

  Dartson(this._entities, {Codec<Object, R> codec}) : this._codec = codec;

  /// Encodes [data] using the encoding method generated by the builder and the
  /// [_codec] if present.
  /// Throws [UnknownEntityException] if the entity wasn't added to the
  /// [Serializer] declaration or provided by extending another serializer.
  R encode<T>(T data) {
    if (!_entities.containsKey(data.runtimeType)) {
      throw UnknownEntityException(data.runtimeType);
    }

    final entity = _entities[data.runtimeType] as DartsonEntity<T>;
    final preData = entity.encoder(data, this);

    if (_codec == null) {
      return preData as R;
    }

    return _codec.encode(preData);
  }

  /// Decodes [data] using the [_codec] if provided and the decoding method
  /// generated by the builder.
  /// Throws [UnknownEntityException] if the entity wasn't added to the
  /// [Serializer] declaration or provided by extending another serializer.
  T decode<T>(R data) {
    Map<String, dynamic> prepData;
    if (_codec != null) {
      prepData = _codec.decode(data);
    } else {
      prepData = data as Map<String, dynamic>;
    }

    if (!_entities.containsKey(T)) {
      throw UnknownEntityException(T);
    }

    final entity = _entities[T] as DartsonEntity<T>;
    return entity.decoder(prepData, this);
  }

  /// Takes the entities of the [instance] and adds the entities of this instance
  /// and use the [_codec] of this instance.
  Dartson<R> extend(Dartson instance) =>
      new Dartson<R>({}..addAll(instance._entities)..addAll(_entities),
          codec: _codec);

  // TODO: Add test case.
  /// Returns a new [Dartson] instance using the provided [codec].
  Dartson<S> useCodec<S>(Codec<Object, S> codec) =>
      new Dartson<S>({}..addAll(_entities), codec: codec);
}

class DartsonEntity<T> {
  final Map<String, dynamic> Function(T obj, Dartson inst) encoder;
  final T Function(Map<String, dynamic> data, Dartson inst) decoder;

  const DartsonEntity(this.encoder, this.decoder);
}
